-*- mode: Org; org-todo-keywords '((sequence "TODO" "DOING" "DONE"))

(defone): "The Habitable Phone OS"

* Intro

Current phone operating systems that treat apps as monoliths.  The
goal of this project is (eventually) to replace this with small
general-purpose components which can be strung together according to
user needs.  

** How?

Using CSP, which for the purpose of this discussion I will summarize
as "like Unix pipes but on steroids".  CSP is about Communicating
Sequential Processes, and the way they communicate is by being
connected together with channels and passing messages on those
channels.  

** No, really, _how_?

Take an Android phone, install a proper Linux distribution and 
a Clojure installation on it, then write/join up components using
core.async.  Input will be from RIL and the internet and tslib, 
output will be via OpenGL(ES)

*** Why Android?

Mostly because it's there.  We piggyback on android to get the kernel
and the drivers for stuff like RIL (the radio/telephony) and wireless
and audio and bluetooth.  We ignore (maybe even delete, eventually)
all the Dalvik stuff.

*** Why not Clojure-on-Dalvik?

No particularly strong reason except that (1) dynamic compilation
looks complicated, (2) putting our own real Linux on instead gives us
a degree of future-proofing by making it more portable

- there are other Linux-based phones that aren't Android or have only
  vestigial Android (Firefox OS, Ubuntu Touch)

- there are ARM Linux devices that aren't even phones (Raspberry Pi
  being the obvious one, plus Sheevaplugs and all that stuff)

The biggest downside of doing it this way, at least that I have so
far noted, is that we don't get Android accelerated display drivers.

*** Why not start with B2G/Firefox OS?

Because I tried building it for my device (Galaxy Nexus) and sheesh is
it complicated.  Modularity FTW: if we can run (defone) on any
powerful-enough hardware that runs a rooted Android, that gives us
many more potential target hardware devices.

* Current status / TODO

(Very) rough, (not at all) ready.

** chroot (Debian)

I've built a chroot with Debian in it and some make targets to get it
onto my phone.  I have tested this works with CyanogenMod (which is
what my phone is running) and with the vanilla Android that the
emulator runs.  I advise against trying to run it on the emulator
unless you have a near-infinite amount of spare time to wait for it,
though.  By which I mean to say, an actual phone will be much faster.

    $ sude -E make -C rootfs

with your phone connected on USB.  This kicks off a multistage
process

- create a Debian chroot
- install rsync on the phone with adb push
- copies the chroot onto the phone
- ssh into the chroot on the phone, apt-get a pile of packages and
  build some more

As with anything based on Make, it may not work.

** graphics (Mesa)

I spent a good while chasing down various rabbit holes in the hope of
getting hw-accelerated GL on my particular phone (Galaxy Nexus).
Eventually I wrote that off as an exercise for Future Me and just
built Mesa instead.

The Makefile will attempt to do this for you but probably fail due to
some search path problem I haven't taken the time to figure out yet.
ssh into the phone then run

    # make -C /defone/stage2

to restart it by hand

Allegedly it builds with llvmpipe, but casual use says it's no faster than
boring old softpipe.  But that could easily be because I haven't
figured out how to enable llvmpipe properly

#+BEGIN EXAMPLE
root@localhost:~/src# EGL_PLATFORM=fbdev GALLIUM_DRIVER=llvmpipe 
 LD_LIBRARY_PATH=/usr/local/lib EGL_LOG_LEVEL=debug  ./eglinfo
libEGL debug: Native platform type: fbdev (environment overwrite)
libEGL debug: EGL search path is /usr/local/lib/egl
libEGL debug: added /usr/local/lib/egl/egl_gallium.so to module array
libEGL debug: added egl_dri2 to module array
libEGL debug: dlopen(/usr/local/lib/egl/egl_gallium.so)
libEGL info: use FBDEV for display 0x3
libEGL debug: the best driver is Gallium
EGL API version: 1.4
EGL vendor string: Mesa Project
EGL version string: 1.4 (Gallium)
EGL client APIs: OpenGL OpenGL_ES OpenGL_ES2 
EGL extensions string:
    EGL_MESA_screen_surface EGL_KHR_image_base EGL_KHR_reusable_sync
    EGL_KHR_fence_sync EGL_KHR_surfaceless_context
Configurations:
     bf lv colorbuffer dp st  ms    vis   cav bi  renderable  supported
  id sz  l  r  g  b  a th cl ns b    id   eat nd gl es es2 vg surfaces 
---------------------------------------------------------------------
0x01 32  0  8  8  8  8  0  0  0 0 0x00SG      a  y  y  y     win,pb,scrn
0x02 32  0  8  8  8  8 16  0  0 0 0x00SG      a  y  y  y     win,pb,scrn
0x03 32  0  8  8  8  8 32  0  0 0 0x00SG      a  y  y  y     win,pb,scrn
0x04 32  0  8  8  8  8 24  8  0 0 0x00SG      a  y  y  y     win,pb,scrn
0x05 32  0  8  8  8  8 24  0  0 0 0x00SG      a  y  y  y     win,pb,scrn
Number of Screens: 1

Screen 0 Modes:
  id  width height refresh  name
-----------------------------------------
0x01   720   1280   60.000  Current Mode
#+END EXAMPLE

** JDK, Clojure

Installed in stage2

** Standalone hacking

It is a goal that we can develop directly on the device without being
dependent on some other machine with an SDK/special software installed.
Since we have no plans currently to support programming without a
keyboard, we will at least be dependent on being able to connect a
keyboard or a device that has one attached

As noted previously, there is ssh which works fine with Emacs
Tramp.  Unfortunately, not every computer in the world has emacs
installed: eventually we may want to install a web server and shellinabox
or something like that.

http://code.google.com/p/shellinabox/

** Touchscreen
** Audio IO

ALSA is standard Linux stuff.  Need to find out if channels are good
for bulk audio data (maybe in 8k blocks or something) or if they
would be best reserved for siganlling and let the actual audio happen
out of bound.

** Telephony

RIL looks at least semi-documented.  Write some stuff to channelise it

** IP Networking
   
Android handles this, no need to get involved
